// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { getConfig } from '../../lib/config';

// Helper to check if we're in a browser environment
const isBrowser = typeof window !== 'undefined';

// Custom storage implementation with safety checks
const customStorage = {
  getItem: (key: string): string | null => {
    try {
      if (isBrowser) {
        return localStorage.getItem(key);
      }
      return null;
    } catch (error) {
      console.error('Error accessing localStorage:', error);
      return null;
    }
  },
  setItem: (key: string, value: string): void => {
    try {
      if (isBrowser) {
        localStorage.setItem(key, value);
      }
    } catch (error) {
      console.error('Error writing to localStorage:', error);
    }
  },
  removeItem: (key: string): void => {
    try {
      if (isBrowser) {
        localStorage.removeItem(key);
      }
    } catch (error) {
      console.error('Error removing from localStorage:', error);
    }
  },
};

// Actual Supabase client instance
let supabaseClient: any = null;
let initializationPromise: Promise<any> | null = null;

// Initialize client asynchronously
async function initializeClientAsync() {
  if (supabaseClient) {
    return supabaseClient;
  }

  if (initializationPromise) {
    return initializationPromise;
  }

  initializationPromise = (async () => {
    try {
      console.log('Initializing Supabase client...');
      const config = await getConfig();
      const SUPABASE_URL = config.VITE_SUPABASE_URL;
      const SUPABASE_PUBLISHABLE_KEY = config.VITE_SUPABASE_ANON_KEY;

      // Validation to ensure environment variables are loaded
      if (!SUPABASE_URL || !SUPABASE_PUBLISHABLE_KEY) {
        throw new Error(
          'Missing Supabase environment variables. Please check your .env file and ensure VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY are set.'
        );
      }

      supabaseClient = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
        auth: {
          persistSession: true,               // Enable session persistence
          storageKey: 'therapist-app-auth',   // Unique storage key for the app
          autoRefreshToken: true,             // Automatically refresh token
          detectSessionInUrl: true,           // Detect OAuth session in URL
          storage: customStorage,
        },
        global: {
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
          }
        },
      });

      console.log('Supabase client initialized successfully');
      return supabaseClient;
    } catch (error) {
      console.error('Failed to initialize Supabase client:', error);
      initializationPromise = null; // Reset so we can try again
      throw error;
    }
  })();

  return initializationPromise;
}

// Start initialization immediately when the module loads
initializeClientAsync().catch(console.error);

// Simple client that waits for initialization on each call
const createSimpleClient = () => {
  return {
    auth: {
      onAuthStateChange: (callback: Function) => {
        // For auth state changes, we need to return the subscription immediately
        // So we'll initialize synchronously if possible, or use a temporary approach
        if (supabaseClient) {
          return supabaseClient.auth.onAuthStateChange(callback);
        } else {
          // Return a mock subscription structure while initializing
          let realSubscription: any = null;
          
          initializeClientAsync().then(client => {
            const result = client.auth.onAuthStateChange(callback);
            realSubscription = result.data.subscription;
          }).catch(console.error);
          
          return {
            data: {
              subscription: {
                unsubscribe: () => {
                  if (realSubscription) {
                    realSubscription.unsubscribe();
                  }
                }
              }
            }
          };
        }
      },
      getSession: async () => {
        const client = await initializeClientAsync();
        return client.auth.getSession();
      },
      signUp: async (credentials: any) => {
        const client = await initializeClientAsync();
        return client.auth.signUp(credentials);
      },
      signInWithPassword: async (credentials: any) => {
        const client = await initializeClientAsync();
        return client.auth.signInWithPassword(credentials);
      },
      signInWithOAuth: async (options: any) => {
        const client = await initializeClientAsync();
        return client.auth.signInWithOAuth(options);
      },
      signOut: async () => {
        const client = await initializeClientAsync();
        return client.auth.signOut();
      }
    },
    from: (table: string) => {
      return createAsyncQuery(table);
    },
    rpc: async (functionName: string, params: any) => {
      const client = await initializeClientAsync();
      return client.rpc(functionName, params);
    }
  };
};

// Special async query handler
function createAsyncQuery(table: string) {
  return new Proxy({}, {
    get(target, prop) {
      return function(...args: any[]) {
        if (prop === 'then') {
          // Handle promise-like behavior
          return initializeClientAsync().then(client => 
            client.from(table)[prop as string](...args)
          );
        } else {
          // Return another proxy for chaining
          return createAsyncQueryChain(table, [[prop as string, args]]);
        }
      };
    }
  });
}

// Handle chained operations
function createAsyncQueryChain(table: string, operations: any[][]) {
  return new Proxy({}, {
    get(target, prop) {
      return function(...args: any[]) {
        const newOperations = [...operations, [prop as string, args]];
        
        if (prop === 'then') {
          // Execute the chain
          return initializeClientAsync().then(client => {
            let query = client.from(table);
            for (const [method, methodArgs] of operations) {
              query = query[method](...methodArgs);
            }
            return query;
          });
        } else {
          // Continue chaining
          return createAsyncQueryChain(table, newOperations);
        }
      };
    }
  });
}

// Export the client directly - it will initialize lazily
export const supabase = createSimpleClient() as any;

// Function to get the real client (for cases where you need the actual instance)
export const getSupabaseClient = async () => {
  return await initializeClientAsync();
};

// Function to clear auth state - useful for debugging
export const clearAuthState = () => {
  try {
    if (isBrowser) {
      // Clear Supabase auth storage
      localStorage.removeItem('therapist-app-auth');
      
      // Clear custom user type storage
      localStorage.removeItem('nokutoru_user_type');
      
      // Clear any admin session data
      localStorage.removeItem('admin_session');
      localStorage.removeItem('admin_user_id');
      
      // Clear any potential session data with different keys
      Object.keys(localStorage).forEach(key => {
        if (key.includes('supabase') || key.includes('auth') || key.includes('sb-')) {
          localStorage.removeItem(key);
        }
      });
      
      console.log('Auth state completely cleared');
    }
  } catch (error) {
    console.error('Error clearing auth state:', error);
  }
};

// Force sign out and clear all auth state - use this for troubleshooting auth issues
export const forceSignOut = async () => {
  try {
    // First attempt normal sign out
    if (supabaseClient) {
      await supabaseClient.auth.signOut();
    }
    
    // Then clear all storage
    clearAuthState();
    
    // Force reload the page
    if (isBrowser) {
      window.location.href = '/';
    }
    
    return { success: true };
  } catch (error) {
    console.error('Force sign out failed:', error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    };
  }
};
