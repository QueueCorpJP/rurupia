// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { getConfig } from '../../lib/config';
import { getSupabaseAuth } from './auth';

// Helper to check if we're in a browser environment
const isBrowser = typeof window !== 'undefined';

// Custom storage implementation with safety checks
const customStorage = {
  getItem: (key: string): string | null => {
    try {
      if (isBrowser) {
        return localStorage.getItem(key);
      }
      return null;
    } catch (error) {
      console.error('Error accessing localStorage:', error);
      return null;
    }
  },
  setItem: (key: string, value: string): void => {
    try {
      if (isBrowser) {
        localStorage.setItem(key, value);
      }
    } catch (error) {
      console.error('Error writing to localStorage:', error);
    }
  },
  removeItem: (key: string): void => {
    try {
      if (isBrowser) {
        localStorage.removeItem(key);
      }
    } catch (error) {
      console.error('Error removing from localStorage:', error);
    }
  },
};

// Actual Supabase client instance
let supabaseClient: any = null;
let initializationPromise: Promise<any> | null = null;

// Initialize client asynchronously
async function initializeClientAsync() {
  if (supabaseClient) {
    return supabaseClient;
  }

  if (initializationPromise) {
    return initializationPromise;
  }

  initializationPromise = (async () => {
    try {
      console.log('Initializing Supabase client (singleton)...');
      supabaseClient = await getSupabaseAuth();
      console.log('Supabase client initialized successfully');
      return supabaseClient;
    } catch (error) {
      console.error('Failed to initialize Supabase client:', error);
      initializationPromise = null; // Reset so we can try again
      throw error;
    }
  })();

  return initializationPromise;
}

// Start initialization immediately when the module loads
initializeClientAsync().catch(console.error);

// Simple client that waits for initialization on each call
const createSimpleClient = () => {
  return {
    auth: {
      onAuthStateChange: (callback: Function) => {
        // For auth state changes, we need to return the subscription immediately
        // So we'll initialize synchronously if possible, or use a temporary approach
        if (supabaseClient) {
          return supabaseClient.auth.onAuthStateChange(callback);
        } else {
          // Return a mock subscription structure while initializing
          let realSubscription: any = null;
          
          initializeClientAsync().then(client => {
            const result = client.auth.onAuthStateChange(callback);
            realSubscription = result.data.subscription;
          }).catch(console.error);
          
          return {
            data: {
              subscription: {
                unsubscribe: () => {
                  if (realSubscription) {
                    realSubscription.unsubscribe();
                  }
                }
              }
            }
          };
        }
      },
      getSession: async () => {
        const client = await initializeClientAsync();
        return client.auth.getSession();
      },
      getUser: async () => {
        const client = await initializeClientAsync();
        return client.auth.getUser();
      },
      signUp: async (credentials: any) => {
        const client = await initializeClientAsync();
        return client.auth.signUp(credentials);
      },
      signInWithPassword: async (credentials: any) => {
        const client = await initializeClientAsync();
        return client.auth.signInWithPassword(credentials);
      },
      signInWithOAuth: async (options: any) => {
        const client = await initializeClientAsync();
        return client.auth.signInWithOAuth(options);
      },
      signOut: async () => {
        const client = await initializeClientAsync();
        return client.auth.signOut();
      },
      updateUser: async (attributes: any) => {
        const client = await initializeClientAsync();
        return client.auth.updateUser(attributes);
      }
    },
    from: (table: string) => {
      return createAsyncQuery(table);
    },
    rpc: async (functionName: string, params: any) => {
      const client = await initializeClientAsync();
      return client.rpc(functionName, params);
    },
    functions: {
      invoke: async (functionName: string, options?: any) => {
        const client = await initializeClientAsync();
        // Supabase Functions invoke options are structured with 'body' for payload
        // and 'headers' etc. Ensure the 'options' passed aligns with this.
        // If 'options' is just the body, it should be { body: options }
        // For simplicity, assuming 'options' is already structured correctly
        // or is just the body, which is a common shorthand.
        // Let's refine to handle common case where options might just be the body.
        let invokeOptions = options;
        if (options && typeof options === 'object' && !('body' in options) && !('headers' in options) && !('method' in options)) {
          // If options is a plain object but not a full FunctionsInvokeOptions, assume it's the body
          invokeOptions = { body: options };
        }
        return client.functions.invoke(functionName, invokeOptions);
      },
    }
  };
};

// Special async query handler
function createAsyncQuery(table: string) {
  return new Proxy({}, {
    get(target, prop) {
      return function(...args: any[]) {
        if (prop === 'then') {
          // Provide a proper thenable so that `await` resolves the final query
          return (resolve: any, reject: any) => {
            initializeClientAsync()
              .then(client => client.from(table))
              .then(builder => (builder as any).then(resolve, reject))
              .catch(reject);
          };
        } else {
          // Return another proxy for chaining
          return createAsyncQueryChain(table, [[prop as string, args]]);
        }
      };
    }
  });
}

// Handle chained operations
function createAsyncQueryChain(table: string, operations: any[][]) {
  return new Proxy({}, {
    get(target, prop) {
      return function(...args: any[]) {
        const newOperations = [...operations, [prop as string, args]];
        
        if (prop === 'then') {
          // Finalize the chain and execute once the real client is ready
          return (resolve: any, reject: any) => {
            initializeClientAsync()
              .then(client => {
                let query: any = client.from(table);
                for (const [method, methodArgs] of operations) {
                  query = query[method](...methodArgs);
                }
                return query;
              })
              .then((builder: any) => builder.then(resolve, reject))
              .catch(reject);
          };
        } else {
          // Continue chaining
          return createAsyncQueryChain(table, newOperations);
        }
      };
    }
  });
}

// Export the client directly - it will initialize lazily
export const supabase = createSimpleClient() as any;

// Expose supabase to the window object for easier debugging in DevTools
if (typeof window !== 'undefined') {
  (window as any).supabase = supabase;
}

// Function to get the real client (for cases where you need the actual instance)
export const getSupabaseClient = async () => {
  return await initializeClientAsync();
};

// Function to clear auth state - useful for debugging
export const clearAuthState = () => {
  try {
    if (isBrowser) {
      // Clear Supabase auth storage
      localStorage.removeItem('therapist-app-auth');
      
      // Clear custom user type storage
      localStorage.removeItem('nokutoru_user_type');
      
      // Clear any admin session data
      localStorage.removeItem('admin_session');
      localStorage.removeItem('admin_user_id');
      
      // Clear any potential session data with different keys
      Object.keys(localStorage).forEach(key => {
        if (key.includes('supabase') || key.includes('auth') || key.includes('sb-')) {
          localStorage.removeItem(key);
        }
      });
      
      console.log('Auth state completely cleared');
    }
  } catch (error) {
    console.error('Error clearing auth state:', error);
  }
};

// Force sign out and clear all auth state - use this for troubleshooting auth issues
export const forceSignOut = async () => {
  try {
    // First attempt normal sign out
    if (supabaseClient) {
      await supabaseClient.auth.signOut();
    }
    
    // Then clear all storage
    clearAuthState();
    
    // Force reload the page
    if (isBrowser) {
      window.location.href = '/';
    }
    
    return { success: true };
  } catch (error) {
    console.error('Force sign out failed:', error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    };
  }
};
