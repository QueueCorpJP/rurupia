// This file is automatically generated. Do not edit it directly.
import { getSupabaseAuth } from './auth';

// Cache for the initialized client
let _clientCache: any = null;

// Helper to get or initialize the client
const getClient = async () => {
  if (!_clientCache) {
    _clientCache = await getSupabaseAuth();
    
    // Expose to window for debugging
    if (typeof window !== 'undefined') {
      (window as any).supabase = _clientCache;
    }
  }
  return _clientCache;
};

// Create a synchronous client interface that delegates to the async singleton
export const supabase = {
  auth: {
    getSession: async () => {
      const client = await getClient();
      return client.auth.getSession();
    },
    getUser: async () => {
      const client = await getClient();
      return client.auth.getUser();
    },
    signUp: async (credentials: any) => {
      const client = await getClient();
      return client.auth.signUp(credentials);
    },
    signInWithPassword: async (credentials: any) => {
      const client = await getClient();
      return client.auth.signInWithPassword(credentials);
    },
    signInWithOAuth: async (options: any) => {
      const client = await getClient();
      return client.auth.signInWithOAuth(options);
    },
    signOut: async () => {
      const client = await getClient();
      return client.auth.signOut();
    },
    updateUser: async (attributes: any) => {
      const client = await getClient();
      return client.auth.updateUser(attributes);
    },
    resetPasswordForEmail: async (email: string, options?: any) => {
      const client = await getClient();
      return client.auth.resetPasswordForEmail(email, options);
    },
    onAuthStateChange: (callback: Function) => {
      // For auth state changes, we need to handle this specially
      getClient().then(client => {
        return client.auth.onAuthStateChange(callback);
      }).catch(console.error);
      
      // Return a dummy subscription for immediate use
      return {
        data: {
          subscription: {
            unsubscribe: () => {
              // Will be replaced when the real client loads
            }
          }
        }
      };
    }
  },
  
  from: (table: string) => {
    // Return an object that provides the query builder interface
    return {
      select: (...args: any[]) => {
        // Return a chainable object
        const createChain = (operations: Array<[string, any[]]>) => ({
          eq: (...eqArgs: any[]) => createChain([...operations, ['eq', eqArgs]]),
          gte: (...gteArgs: any[]) => createChain([...operations, ['gte', gteArgs]]),
          lte: (...lteArgs: any[]) => createChain([...operations, ['lte', lteArgs]]),
          order: (...orderArgs: any[]) => createChain([...operations, ['order', orderArgs]]),
          limit: (...limitArgs: any[]) => createChain([...operations, ['limit', limitArgs]]),
          or: (...orArgs: any[]) => createChain([...operations, ['or', orArgs]]),
          in: (...inArgs: any[]) => createChain([...operations, ['in', inArgs]]),
          single: async () => {
            const client = await getClient();
            let query = client.from(table).select(...args);
            for (const [method, methodArgs] of operations) {
              query = query[method](...methodArgs);
            }
            return query.single();
          },
          maybeSingle: async () => {
            const client = await getClient();
            let query = client.from(table).select(...args);
            for (const [method, methodArgs] of operations) {
              query = query[method](...methodArgs);
            }
            return query.maybeSingle();
          },
          // Make it thenable so it can be awaited directly
          then: async (resolve: any, reject: any) => {
            try {
              const client = await getClient();
              let query = client.from(table).select(...args);
              for (const [method, methodArgs] of operations) {
                query = query[method](...methodArgs);
              }
              const result = await query;
              resolve(result);
            } catch (error) {
              reject(error);
            }
          }
        });
        
        return createChain([]);
      },
      
      insert: (...args: any[]) => ({
        select: async (...selectArgs: any[]) => {
          const client = await getClient();
          return client.from(table).insert(...args).select(...selectArgs);
        },
        // Make it thenable for direct await
        then: async (resolve: any, reject: any) => {
          try {
            const client = await getClient();
            const result = await client.from(table).insert(...args);
            resolve(result);
          } catch (error) {
            reject(error);
          }
        }
      }),
      
      update: (...args: any[]) => ({
        eq: (...eqArgs: any[]) => ({
          select: async (...selectArgs: any[]) => {
            const client = await getClient();
            return client.from(table).update(...args).eq(...eqArgs).select(...selectArgs);
          },
          then: async (resolve: any, reject: any) => {
            try {
              const client = await getClient();
              const result = await client.from(table).update(...args).eq(...eqArgs);
              resolve(result);
            } catch (error) {
              reject(error);
            }
          }
        }),
        then: async (resolve: any, reject: any) => {
          try {
            const client = await getClient();
            const result = await client.from(table).update(...args);
            resolve(result);
          } catch (error) {
            reject(error);
          }
        }
      }),
      
      delete: () => ({
        eq: async (...eqArgs: any[]) => {
          const client = await getClient();
          return client.from(table).delete().eq(...eqArgs);
        }
      }),
      
      upsert: async (...args: any[]) => {
        const client = await getClient();
        return client.from(table).upsert(...args);
      }
    };
  },
  
  rpc: async (functionName: string, params: any) => {
    const client = await getClient();
    return client.rpc(functionName, params);
  },
  
  channel: (channelName: string) => {
    // For realtime subscriptions, we need to use a cached client if available
    // or create a temporary one since realtime needs immediate access
    if (_clientCache) {
      return _clientCache.channel(channelName);
    }
    
    // If no cache available, create a temporary channel that will be replaced
    // when the client is ready
    const placeholder = {
      on: () => placeholder,
      subscribe: () => ({ unsubscribe: () => {} })
    };
    
    // Try to get client and replace placeholder
    getClient().then(client => {
      const realChannel = client.channel(channelName);
      Object.assign(placeholder, realChannel);
    }).catch(console.error);
    
    return placeholder;
  },
  
  functions: {
    invoke: async (functionName: string, options?: any) => {
      const client = await getClient();
      return client.functions.invoke(functionName, options);
    }
  },
  
  storage: {
    from: (bucket: string) => ({
      upload: async (path: string, file: File, options?: any) => {
        const client = await getClient();
        return client.storage.from(bucket).upload(path, file, options);
      },
      getPublicUrl: (path: string) => {
        // Return the same structure as the original Supabase client: { data: { publicUrl: string } }
        const result = {
          data: {
            publicUrl: ''
          }
        };
        
        // Try to get the URL immediately if client is already cached
        if (_clientCache) {
          const urlResult = _clientCache.storage.from(bucket).getPublicUrl(path);
          result.data.publicUrl = urlResult.data.publicUrl;
          return result;
        }
        
        // If no cache, return empty URL (this should rarely happen since auth loads first)
        console.warn('Storage client not ready, returning empty URL for path:', path);
        return result;
      },
      download: async (path: string) => {
        const client = await getClient();
        return client.storage.from(bucket).download(path);
      },
      remove: async (paths: string[]) => {
        const client = await getClient();
        return client.storage.from(bucket).remove(paths);
      }
    })
  }
};

// Re-export the client getter for compatibility
export const getSupabaseClient = getClient;

// Function to clear auth state - useful for debugging
export const clearAuthState = () => {
  try {
    if (typeof window !== 'undefined') {
      // Clear Supabase auth storage
      localStorage.removeItem('therapist-app-auth');
      
      // Clear custom user type storage
      localStorage.removeItem('nokutoru_user_type');
      
      // Clear any admin session data
      localStorage.removeItem('admin_session');
      localStorage.removeItem('admin_user_id');
      
      // Clear any potential session data with different keys
      Object.keys(localStorage).forEach(key => {
        if (key.includes('supabase') || key.includes('auth') || key.includes('sb-')) {
          localStorage.removeItem(key);
        }
      });
      
      console.log('Auth state completely cleared');
    }
  } catch (error) {
    console.error('Error clearing auth state:', error);
  }
};

// Force sign out and clear all auth state - use this for troubleshooting auth issues
export const forceSignOut = async () => {
  try {
    // First attempt normal sign out
    const client = await getClient();
    await client.auth.signOut();
    
    // Then clear all storage
    clearAuthState();
    
    // Force reload the page
    if (typeof window !== 'undefined') {
      window.location.href = '/';
    }
    
    return { success: true };
  } catch (error) {
    console.error('Force sign out failed:', error);
    return { 
      success: false, 
      error: error instanceof Error ? error.message : 'Unknown error' 
    };
  }
};
